<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
  

    <body>
     <ul id="xx" style="border: 1px solid green;">
         <li style="border:1px solid yellow;"><span style="border: 1px solid red; display: inline-block;;">lalalallalal</span></li>
         <li>2</li>
         <li>3</li>
         <li>4</li>
         <li>5</li>
     </ul>
    </body>
    <script>
    //    function delegate(element, eventType, selector, fn) {
    //     // ul click span fn
    //         // element ul selector li
    //         element.addEventListener(eventType, e => {
    //             let el = e.target
    //             console.log('el', el)
    //             while (!el.matches(selector)) {
    //                 console.log('i am here', 'selector', selector)
    //                 if (el == element) {
    //                     console.log('我是最外层', el)
    //                     el = null
    //                     break
    //                 }
    //                 console.log(' el.parentNode',  el.parentNode)
    //                 el = el.parentNode
    //             }
    //             console.log('el-----x', el)
    //             el && fn.apply(el, e, el)
    //         })
    //         return element
    //     } 
    //     function fn(){
    //         console.log('我在这')
    //     }
        let ul = document.getElementById("xx");
        // delegate(ul, 'click', 'span', fn)
        ul.addEventListener('click', function(e){
            console.log('e.target', e.target)
        })


        // // 事件代理
        // //ul-->li-->span|div|
        // //如何代理监听ul下的li事件 将事件监听绑定到ul上面，由于冒泡原理 当li标签被点击的时候 就会冒泡到ul上面
        // //但是如果html结构是 在点击li标签下面的div或者span的时候如何判断监听，此时需要循环
        // <ul>
        //   <li>
        //     <div><span></span></div>
        //   </li>
        // </ul>
        // function delegate(element, eventType, selector, fn){
        //   //element相当于ul
        //   //eventType 相当于click
        //   //selector 相当于li元素
        //   //通过e.target可以知道当前点击的是哪个元素
        //   element.addEventListener(eventType, e => {
        //     let el = e.target
        //     while(!el.matches(selector)){   //如果当前点击的元素不是li元素 如果不匹配 执行while循环，如果是 跳过while循环 直接执行后面的函数
        //       if(element === el){ //如果当前元素是ul 那么对于ul的点击事件 将el置空 不做任何操作
        //         el = null 
        //         break
        //       }
        //       el = el.parentNode //如果当前元素不是ul也不是li元素 那么寻找当前元素的父节点 然后继续while循环判断 直到循环跳出
        //     }
        //     el && fn.call(el, e, el)  //只有在当前点击元素是li元素或者当前点击元素的父节点是li元素时 才执行函数
        //   })
        
    </script>
</html>
