// 1，用户输入url并回车
// 2，浏览器进程检查url，组装协议，构成完整的url
// 3，浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
// 4，网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
// 5，如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
//     5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
//     5.2 利用ip地址和服务器建立tcp连接
//     5.3 构建请求头信息
//     5.4 发送请求头信息
//     5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
// 6，网络进程解析响应流程；
//     6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
//         （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
//     6.2 200响应处理：
//         检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
//         后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
// 7，准备渲染进程
//     7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
// 8. 传输数据、更新状态
//     8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
//     8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
//     8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。

//渲染进程
// - 浏览器不能直接理解html数据 所以第一步需要将其转换为浏览器能够理解的dom树结构
// - 生成dom树后 还需要根据css 样式表 来计算出dom树所有节点的样式
// - 最后计算dom元素的布局信息 使其都保存在布局树中
// - 浏览器的页面实际上被分成了很多图层 这些图层叠加后合成了最终的页面，并不是布局树的每个节点都包含一个图层 如果一个节点没有对应的层 那么这个几点就从属于父节点的图层

// 渲染流程大致如下：
// 1.渲染进程将html内容转换为能够读懂的dom树的结构
// 2.渲染引擎将css样式表转换为浏览器可以理解的stylesheets 计算出dom节点的样式
// 3.创建布局树 并计算元素的布局信息
// 4.对布局树进行分层 并生成分层树
// 5.为每个图层绘制列表 并将其提交到合成线程
// 6 合成线程将图层分成图块 并在光栅化线程池中将图块转换成位图
// 7 合成线程发送绘制图块命令drawquad 给浏览器进程
// 8 浏览器进程根据drawquad消息生成页面 并显示到显示器上
