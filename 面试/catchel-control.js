// cache-chontrol Expires 属于强缓存 last-modified Etag 属于协商缓存
// 如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。
// cache-control: max-age 浏览器事件
// Expires 缓存过期时间 用来指定资源到期的时间 根据的是客户端时间 但是正因为是绝对时间，如果客户端时间被随意更改下，这个机制就失效了
// [Cache-Control]优先级高于[Expires]

// 强缓存 不会向服务器发送请求 直接从缓存中读取资源
// 协商缓存 强制缓存失效后 浏览器携带缓存标识向服务器发起请求 由服务器根据缓存标识决定是否使用缓存的过程 协商缓存生效 返回304 和 not modified

// 1 Last-Modified和If-Modified-Since 服务器时间
// 缺点：1、某些服务端不能获取精确的修改时间  2、文件修改时间改了，但文件内容却没有变

// etag 是对该资源的一种唯一标识  只要资源有变化 etag就会重新生成 在下次向服务器发送请求的时候 会将
// 上一次返回的etag值放在 if-none-match里面 服务器只需要比较客户端传阿里的if-none-match跟自己服务器上该
//资源的etag是否一致    ----     分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）

// 2.2.3 协商缓存两种方式的对比
// 优先级上，服务器校验优先考虑Etag
// 首先在精确度上，Etag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改
// ，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
// 性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。




// require: node 和 es6都支持的引入
// export / import : 只有es6支持的导出引入
// module.exports / exports: 只有node支持的导出
// node 模块尊选的commonjs规范
// 在一个node执行文件时 会给这个文件内生成一个exports 和 module 对象  module 又有一个exports属性


// 1 重排
//  如果通过js活着css更改属性位置 例如改变元素的宽度高度等 那么浏览器回触发重新布局
// 2 重绘
//  通过js更改某些元素的背景颜色 布局阶段将不会被执行 直接进入绘制阶段 
// 3 合成
//  如果更改一个既不需要布局也不需要绘制的属性 渲染引擎会跳过布局和绘制 只执行后续的合成操作
//  利用css的transoform实现动画效果


// css选择器优先级：
// 优先级由高到低可分为：
// 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。
// 作为 style 属性写在元素内的样式
// id 选择器
// 类选择器 = 伪类选择器 = 属性选择器 （后面的样式会覆盖前面的样式）
// 标签选择器
// 通配符选择器
// 浏览器自定义的样式



//  打开一个tab 至少开启4个进程 浏览器进程 渲染进程 网络进程 gpu进程  插件进程
//  浏览器进程： 主要负责界面显示 用户交互 子进程管理 同时提供存储功能
//  渲染进程 将html css js 转换为用户可以与之i 见哦阿虎的网页 默认情况下 chrome会为每个tab创建一个渲染进程
//  gpu进程 gpu使用的初衷是为了实现3d css的效果
//  网络进程 主要负责页面的网络资源加载
//  插件进程 主要负责插件的运行


// http - 安全层 - tcp
// 安全层 有两个主要职责： 对发起http请求的数据进行加密操作 和 对接收到http的内容进行解密操作

加密方法

// 对称加密： 加密和解密都是用相同的密钥
// 1.浏览器发送它所支持的加密套件列表和一个随机数client-random
// 2.服务器会从加密套件列表选取一个加密套件，然后会生成一个service-random 并将service-random 和 加密套件列表返回给浏览器
// 最后浏览器和服务器分别返回确认消息  浏览器和服务端拥有了相同的client-random 和 serveice-random
//  使用相同方法将clinet-random 和 service-random 混合起来生成一个密钥 master secret 有了master secret 和 加密套件 双方就可以进行数据的加密传输了

// 缺点： client-random 和 service-random 的过程是明文的 意味着黑客也可以拿到协商的加密套件和双方的随机数 由于利用随机数合成密钥的算法是公开的 所以黑客拿到随机数之后 也可以合成密钥

使用非对称加密
// 非对称加密算法有a,b两把密钥， 如果你用a密钥来机密 那么只能使用b密钥来解密 反过来 如果你要用b密钥加密 那么只能用a密钥来解密

// 1 浏览器发送加密套件列表给服务器
// 2 服务器会选择一个加密套件 不过和对称加密不同的是 使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密http数据的私钥
// 由于公钥是给浏览器加密使用的 因此服务器会将加密套件和公钥一道发送给浏览器
// 3 最后就是浏览器和服务器返回确认信息

// 缺点 非对称加密的效率太低 无法保证服务器发送给浏览器的数据安全

对称加密和非对称加密搭配使用

// 传输数据阶段依然使用对称加密 但是对称加密的密钥我们采用非对称加密来传输

// 1.浏览器想服务器发送对称加密套件列表 非对称加密套件列表和随机数 client-random
// 2 服务器保存clinet-random 选择对称加密和非对称加密的套件 然后生成随机数service-random 向浏览器发送选择的加密套件 service-random和公钥
// 3 浏览器保存公钥 并生成随机数pre-master 然后利用公钥 pre-master 加密 并向服务器发送加密后的数据
// 4 最后服务器拿出自己的私钥 解密出pre-master 数据 并返回确认信息
// 服务器和浏览器就有了共同的clinet-random 和 service-random 和 pre-master 然后服务器和浏览器会使用这三组随机数生成对称密钥 因为服务器和浏览器使用同一套方法来生成密钥 所以最终生成的密钥也是相同的

// pre-master 是经过公钥加密后传输的 黑客无法获取到pre-master

// 以上方法都有点弱 黑客还是可以通过dns劫持 将你的地址替换成黑客的地址 黑客的地址就可以获得公钥和私钥 去搞你 所以就有了ca证书
// ca 一个是通过数字证书向浏览器证明服务器的身份 另一个是数字证书里面包含了服务器的公钥
// // 相比第三版https协议
// 1. 服务器没有直接返回公钥给浏览器 而是返回了数字证书 而公钥正是包含在数字证书中的
// 2. 在浏览器端多了一个证书验证操作 验证了证书之后 才继续后续流程

// xss 存储型xss攻击 反射型xss攻击 和 基于dom的xss攻击
// 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击

// http0.9 非常简陋 为了后面支持的多样性 发展除了http1.0(提供了对多文件的良好支持)
// http1.0 每进行一次http通信 都要经历tcp链接 传输http数据和断开tcp链接三个阶段 这样在面对页面的图片文件越来越多 有时候一个页面包含了几百个外部引用的资源文件
// 如果下载每个文件的时候 都要经历tcp链接 传输数据 和断开联接 这样的步骤 无疑会增加大量无谓的开销

// http1.1 增加了持久链接的方法 它的特点是在一个tcp链接上 可以传输多个http请求 只要浏览器或者服务器没有明确断开链接 那么改tcp链接会一直保持
// http1.1 中国默认开启持久链接 如果不想采用持久链接 在http请求头加上connection：close 浏览器对同一个域名默认允许同时建立6个tcp持久链接

// http持久链接 虽然可以减少tcp的建立和断开次数 但是需要等待前面的请求返回之后 才能进行下一次的请求 如果tcp通道中的某个请求因为某些原因没有及时返回就会阻赛后面所有的请求 队头阻赛

// http1.1 增加了持久链接 浏览器为每个域名最多同时维护6各tcp持久链接 使用cdn的实现域名分片机制

// http1.1的主要问题： 对带宽利用率不理想  原因 1tcp的慢启动 2 同时开启了多条tcp连接  连接会竞争固定的带宽 3.队头阻赛

// http2 多路复用 ---》http3还没有广泛适用浏览器 + quic协议



// 图片格式分类
// 无压缩 无压缩的图片格式不对图片数据进行压缩处理 能准确的呈现图片 bmp格式就是其中之一
// 无损压缩 压缩算法对图片的所有数据进行编码压缩 能在保证图片的质量的同时降低图片的尺寸 png就是其中的代表
// 有损压缩 压缩算法不会对图片所有数据进行编码压缩 而是在压缩的时候 去除了人眼中无法识别的图片细节 因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸 其中的代表是jpg
// gif
// webp 格式的支持度不是很好

// gif
// 文件小，支持动画、透明，无兼容性问题
// 只支持256种颜色
// 色彩简单的logo、icon、动图

// jpg
// 色彩丰富，文件小
// 有损压缩，反复保存图片质量下降明显
// 色彩丰富的图片/渐变图像

// png
// 无损压缩，支持透明，简单图片尺寸小
// 不支持动画，色彩丰富的图片尺寸大
// logo/icon/透明图

// webp
// 文件小，支持有损和无损压缩，支持动画、透明
// 浏览器兼容性不好
// 支持webp格式的app和webview



// 实现原理类似于jsonp
// 1 首先在h5中注入一个callback方法，放在window对象中 然后把callback的名字 通过url schema传到native
// 2 native 通过shouldOverrideUrlLoading()拦截到webview的请求 并通过与前端约定好的url schema判断是否是jsb调用
// 3. native解析出前端带上的callback 并使用下面方式调用callback


// 1234 "4321"
function test(num) {
    let str = ''
    let getStr = function (num) {
        if (num % 10) {

        }
    }
}




// 2.url长度限制原因
// 3.说下其他请求方式
// 6.渲染html页面的过程
// 8.async和defer，附加循环机制
// 10.防抖节流的概念和应用场景
// 12.读代码输出，解释原因
// 14.v-for/v-bind原理
// 15.实现一个双向绑定
// 2.dom操作
// 3.写一个方法，找到两个数组的最大值（写完），问如果用Math.max怎么实现（apply），问不用apply呢（...运算符）
// 5.实现一个计数器
// 6.flex相关，都有哪些属性，写一个布局，左100px，右充满
// 3.用户对某页面没有权限，在前端如何处理
// 4.最后问了个如何生成1-9a-zA-Z生成5位随机数
// 映射到62位，生成个0-61的随机数，遍历5遍
// 节流、和防抖的区别，均匀的节流怎么实现【编程】
// 一下子写了最简单的出来，然后他要各种改需求，加功能。要支持配置马上执行、要防抖节流两个结合起来、要均匀
// 前端路由实现。history什么坑，怎么解决【描述】
// 哈希和history，监听事件、切换元素。history会导致一些新路径404，nginx重定向到首页走js逻辑
// var 、let、const区别，() => { } vs function () { } 【描述】
// 基础送分题
// 一副扑克牌，随机抽 5 张，判断是否是顺子，大小王可以替代任意牌。【编程】
// ['A', '2', '3', 'S', 'B'] true
// 先把AJQK映射成数字，然后把大小王S、B换成其他(我直接用symbol代替了) 。排序去掉大小王的数组。遍历排序后数组，前一个数和后一个数字差距大于1，减少大小王数量来补。临界条件：前一个数和后一个数字差距大于1且大小王不够补，return false；成功遍历所有的元素，return true
// 这里有点尴尬，忘记转数字类型了，很快写完了，但一直有问题，傻乎乎的debug，牛客网打印出来的结果也不知道是什么类型，都是黑色字。后面猜测是类型问题，typeof一看，哦果然是类型问题，加一个 + 号转数字，解决
// 2面面试官喜欢挖问题继续问，防抖节流硬生生写成了一个几十行的轮子了，不过我挺喜欢这种面试模式，临时造轮子改需求，随意天马行空地发挥，很好玩
// 项目难点，画一下架构【举例】
// 临时给了一个在线文档地址，然后手绘了架构图
// 有了解其他权限系统吗，对比下【描述】
// 纠结了一阵我做的权限系统究竟是rbac几。前端控制、后端按需返回
// 怎么知道一个tcp请求数据已经完了呢【描述】
// 微博的@的下面出现一个提示怎么实现(pc上，类似群里讲话按下@，旁边有一个名字下拉框的那个功能)。不是editable喔，基于textarea怎么实现【伪代码】【描述】
// 一下子说了editable，他说你看看，他是textarea。接着有两种方式，隐藏元素+getboundingclientrect和canvas的mesuretext量长度。他后面说量长度不太行，而且很麻烦
// 怎么知道客户端是局域网下哪一个ip【描述】
// 客户端连接服务端的时候会携带自己的ip，服务器接收
// 为什么是tcp而不是udp。tcp丢包怎么办，怎么知道丢包，怎么知道已经重传成功了【描述】
// TCP三次握手保证可靠性，而UDP就没有了，信息发出后,不验证是否到达，不可靠。丢包就重传。有seq，是连续的，如果收到的是不连续，说明中间缺了包；或者是超时了还没收到。因为有seq吧，所以多一个少一个也是知道的
// 了解http3的quic吗【描述】
// udp快而不可靠，所以衍生quic。对比http2+tcp+tls，quic减少了tcp、tls握手，改进了拥塞控制，前向冗余纠错
// quic怎么解决了tcp的问题【描述】
// 使用udp作为基础，瞎讲一通拥塞控制、前向冗余纠错、bbr，所知道的概念都甩出去了
// quic用udp怎么保证了可靠性【描述】
// 用rudp来优化资源的占用率和响应时间，提高系统的并发能力。seq、超时重传、fec前向纠错
// quic的udp如果不握手，人家随便发请求怎么办【描述】
// 滑动窗口、bbr 拥塞算法
// 函数式编程、纯函数【描述】
// 先喘一口气，终于不问网络协议了。纯函数无副作用，同样的输入同样的输出。那我在里面定义变量和函数，里面做一些事情做一些修改这些变量的操作，还纯吗？一样的。
// 状态管理系统设计，怎么和函数式编程结合【描述】【举例】
// 数组和链表的区别【描述】
// 数组易读取，链表只能一个个读或者需要额外空间才能易读取；数组增删元素需要照顾index，链表不用
// 数组和链表优点缺点，应用场景【举例】
// 数组增删的时候需要维护index，链表不需要考虑，但链表读取某一项就比较麻烦。很多情况下，简单的列表遍历用哪个都一样。数组的优势在于需要index的时候，随时读取某一个。链表可以模拟任何流程，并可以随时中断/继续，比如react的fiber使用链表可以随时回到当前状态
// 这是部门前端老大了，也是最难的一面了，被虐到狗血淋头。面试官人挺温柔的，前面的题答出来的时候也感觉很舒畅。后面各种被虐，因为不是科班出身，这些知识细节漏了太多，我只能尽自己所了解的都吐出去了，可能说了很多含含糊糊的、没有系统性的东西，知道什么和那个点相关的都讲了。我看见他在旁边笑了(感觉是"你还是太年轻了"的那种笑)，忽然感觉局面很凉，第一次彻底的慌了，然后到了彻底的崩溃。回去我也默认自己三面挂了，结果过了几天，说offer到了。。。
// 遇到了本次出去社招最难一面，也充分暴露出野生前端的不足，计算机网络知识不系统，零零散散。这一块后面得回头补一下。
// 他们部门用的是ng全家桶，自动化测试也做得很到位。至于为什么用ng，他们老大说：“因为react生态太丰富了，我们做技术选型或者开发到后面会经常要考虑对比各种方案、要调研，不想花太多时间纠结生态，直接上ng一了百了”。这个理由，挺有道理的，我在我们团队也做过一些系统的前端架构设计、做过技术选型、带头做过升级react，也取得让我引以为傲的效果，但就没有往这个方面去思考过，面试官这个思考角度让我豁然开朗——原来事情可以这样思考。另外，现在ng的ivy也挺出彩的，大家有时间可以去了解一下
// 猿辅导是个很不错的公司，技术也挺强的，而且一般78点下班。还有，别忘了猿辅导是传说中开发实习生800一天的公司，除了这个，福利也挺多、挺到位的
// 3.display常见的值以及区别
// 4.你知道哪些元素默认是inline-block的
// 5.position属性的区别
// 6.子容器垂直水平居中
// 7.代码题。数组去重，不能用set。写了个简单版，然后面试官问，你怎么考虑原型上本来就存在的属性，会不会导致判断出错？如何避免？（当时没答上来，我回答了一个Object.create(null)，但后面下来查资料发现可以用hasOwnProperty，面试官也应该想听到我说hasOwnProperty）
// 8.代码题。n*n数组，从a[0][0]走到a[n-1][n-1]有多少种走法。我写的是用递归，然后面试官说，这样子如果n的规模是几十几百你这算法就跑不动了。接着我给面试官说了一下dp（动态规划）的思路。这道题也确实该用递归。
// 7.JS解决单线程的方法
// 8.ES5、ES6的区别
// 10.Class实现面向对象的原理。Class的继承说一下。
// 11.代码题。给定一个包含大写英文字母和数字的句子，找出这个句子所包含的最大的十六进制整数，返回这个整数的值。数据保证该整数在int表示范围内。例如："012345BZ16" ，最大数“12345B”对应十进制为1193051。

// （这个代码题就很有意思了啊，我最开始写的时候忽略了parseInt的第二个参数导致多写了很大一堆，我傻乎乎的一位一位的加）

// function solve( s ) {     // write code here   // 记录最大的字符串   let maxstr = ''   // 记录最大的值   let maxnum = 0   // 全局匹配符合要求的字符串   let arr = s.match(/[0-9A-F]+/g)   // 记录当前执行的字符串的长度   let templen = 0   for(let i = 0; i < arr.length; i++){       // 这个if是用来过滤比之前运行过的字符串更短的字符串       // 短的字符串肯定比之前的数字小       // 当然还可以直接比较字符串的大小，然后再进行运算     if(arr[i].length >= templen){       templen = arr[i].length       let temp = parseInt(arr[i],16)       if(temp > maxnum){         maxstr = arr[i]         maxnum = temp       }     }   }   return maxnum }
// 1，前端有哪些请求，(get,post..)
// 3，什么叫跨域，有什么解决方式
// 5，XSS攻击(这个说不了解)
// 6，CSS有哪几种选择器
// 7，怎么实现垂直居中，包含的div需要其他样式吗
// 8，<input type=“checkbox"><span>内容</span>，选中的时候把span的内容变成红色，这个回答的不好
// 9，js的基本数据类型有哪些
// 10，说出数组的五种方法
// 11，call和apply的区别
// 12，代码题，实现一个方法，返回一个随机的十六进制的颜色，用数组写的随机，然后面试官提了一种方法，按照他的写正则没写出来
// 对了还有个题是问有没有做过图片轮播，没有做过，然后说一下思路。
// promise的理解，有哪几种状态
// ajax请求的过程


// 1，用户输入url并回车
// 2，浏览器进程检查url，组装协议，构成完整的url
// 3，浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
// 4，网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
// 5，如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
//     5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
//     5.2 利用ip地址和服务器建立tcp连接
//     5.3 构建请求头信息
//     5.4 发送请求头信息
//     5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
// 6，网络进程解析响应流程
//     6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
//         （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
// 301 永久重定向 302 临时重定向
//     6.2 200响应处理：
//         检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
//         后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
// 7，准备渲染进程
//     7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
// 8. 传输数据、更新状态
//     8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
//     8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
//     8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。

//渲染进程
// - 浏览器不能直接理解html数据 所以第一步需要将其转换为浏览器能够理解的dom树结构
// - 生成dom树后 还需要根据css 样式表 来计算出dom树所有节点的样式
// - 最后计算dom元素的布局信息 使其都保存在布局树中
// - 浏览器的页面实际上被分成了很多图层 这些图层叠加后合成了最终的页面，并不是布局树的每个节点都包含一个图层 如果一个节点没有对应的层 那么这个几点就从属于父节点的图层

// 渲染流程大致如下：
// 1.渲染进程将html内容转换为能够读懂的dom树的结构
// 2.渲染引擎将css样式表转换为浏览器可以理解的stylesheets 计算出dom节点的样式
// 3.创建布局树 并计算元素的布局信息
// 4.对布局树进行分层 并生成分层树
// 5.为每个图层绘制列表 并将其提交到合成线程
// 6 合成线程将图层分成图块 并在光栅化线程池中将图块转换成位图
// 7 合成线程发送绘制图块命令drawquad 给浏览器进程
// 8 浏览器进程根据drawquad消息生成页面 并显示到显示器上

// 浏览器进程---网络进程----渲染进程



```JavaScript
// px 方式
document.documentElement.style.fontSize = document.documentElement.clientWidth / 3.75 + 'px'
// vw 方式
document.documentElement.style.fontSize = 100 / 3.75 + 'vw'
/*
    这样写逻辑很简单
    我们的设计标准图是 375px(也可以说是标准设备宽度), 为了方便计算 先暂定转换比例 1rem = 100px
    那么我们的设计宽度就是 3.75rem  (如果设计图是 750px  那么设计宽度就是 7.5rem)
    那么如何实现不同设备的宽度等比例于标准设备宽度呢?

    我们先求出标准3.75rem设计宽度下,我们的可得到的转换比例
    推导 (3.75rem * 转换比例px/rem = 设备宽度px) => (设备宽度 / 3.75 = 转换比例) =>
    => document.documentElement.clientWidth / 3.75  这就是我们求得的转换比例
    => 也就是 375(标准设备宽度) / 3.75 = 100 即375设备下,我们的基准是100 1rem=100px
    => 其他设备 / 标准设备 = 其他比例 / 100(基准比例) = 实际比例  => 实际比例 * 100 = 实际转换比例

    ui设计图永远都是基准设备 即1rem = 100px 所以 ui 60pt计算就是 60 / 100 = 0.6rem

    如果是vw  就是 100 / 3.75 + 'vw' (100  就是设备宽度,vw的意义就是100vw等于document.documentElement.clientWidth+'px')
*/
```

// px是相对于显示器屏幕分辨率而言的
// em是相对长度单位 相对于当前对象内文本的字体尺寸 参考物是父元素的font-size 如果当前父元素的字体尺寸未设置 则相对于浏览器的默认字体尺寸
// rem 是相对于html根元素的字体大小来计算的长度单位
// vw是相对viewport的宽度而定的 长度等于 viewport宽度的1/100  假如浏览器的宽度为200px 那么1vw就等于2px
// vh是相对于viewport的高度而定的 长度等于viewport高度的1/100 


// 中间人攻击
// 1 服务器向客户端发送公钥
// 2 攻击者截获公钥 保留在自己手上
// 3 然后攻击者自己生成一个 伪造的 公钥 发给客户端
// 4 客户端收到伪造的公钥后 生成加密的hash值发给服务端
// 攻击者获得加密的hash值 用自己私钥揭秘获得真密钥
// 同时生成假的加密的hash值发给服务器
//服务器用私钥解密获得的假密钥
// 服务器用加密钥加密传输信息

// 防范方法 服务端在发送浏览器的公钥中加入ca证书 浏览器可以验证ca证书的有效性

// 对称加密 加密和解密用的是同一把钥匙 优点 算法简单 加密解密容易 效率高 执行快 缺点 相对来说不算特别安全 只有一把钥匙 秘文如果被拦截 且密钥也被劫持 那么信息很容易被破译
// 非对称加密 有两把钥匙 一把公钥 一把 私钥  优点 安全 即使密文被拦截 公钥被获取
// 但是无法获取到私钥 也就无法破译密文 作为接收方 无比要保管好自己的密钥 缺点 加密算法及其复杂 安全性依赖算法于密钥 而且加密和解密效率第

// 数字证书

//

//  ssr
// 服务端渲染 将组件或页面通过服务器生成html字符串 再发送到浏览器 最后将静态标记混合为刻画段上完全交互的应用程序
// 与传统的spa相比 ssr有利于seo 减少页面首屏加载时间 和服务器简单输出静态文件相比 通过node去渲染出页面在传递给客户端显然开销是比较大的 
// 需要注意准备好相应的服务器负载


// --------v8
// 支持隐式类型转换的语言称之为若类型语言 不支持隐式类转换的语言称为强类型语言
// 使用之前就需要确认其变量数据类型的称为静态语言

// js数据类型
// boolean null undefined number bigint string symbol object

// 对象是存放在堆空间的 在栈空间中只是保留了对象的引用地址 当js需要访问该数据的时候 是通过栈中的引用地址来访问的

// 在线程执行过程中 能接收并执行新的任务 就需要采用事件循环机制

// ------defer和async-----
// 对于defer，我们可以认为是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用。

// 对于async，这个是html5中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行在有async的情况下，
// js一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果js前后有依赖性，用async，就很有可能出错。

// new
// 原型链
//eventloop
// map如何存取的
// vue 组件渲染


// for...in用于遍历对象的可枚举属性，包括其原型链上的属性。这种循环通常用于对象（object）的属性遍历。示例如下：
// for...of则用于遍历可迭代对象（包括 Array、Map、Set、String、TypedArray、arguments对象等等）。在每次迭代中，for...of会取出可迭代对象的一个元素，而不是像for...in那样取出一个键。示例如下：

// 原型存在的意义就是组成原型链
// 原型链存在的意义就是继承
// 继承存在的意义就是为了属性共享


// flex-grow指定了容器剩余空间多余时候的分配规则，默认值是0，多余空间不分配
// flex-shrink指定了容器剩余空间不足时候的分配规则，默认值是1，空间不足要分配
// flex-basis则是指定了固定的分配数量，默认值是auto。如会忽略设置的同时设置width或者height属性。flex-basis包含大量的细节知识，这个可以专门开一篇文章深入探讨。